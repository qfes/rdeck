% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scales.R
\name{scale_symlog}
\alias{scale_symlog}
\alias{scale_color_symlog}
\title{Scale symlog}
\usage{
scale_color_symlog(
  col,
  palette = scales::viridis_pal(),
  na_color = "#000000",
  limits = NULL,
  breaks = NULL,
  n_ticks = NULL,
  tick_format = format_number,
  col_label = "{.col}",
  legend = TRUE
)

scale_symlog(
  col,
  range = 0:1,
  na_value = 0,
  limits = NULL,
  breaks = NULL,
  col_label = "{.col}",
  legend = TRUE
)
}
\arguments{
\item{col}{<\code{name} | \code{string}> The name of the column containing data to be scaled.
Must be a valid input to \code{\link[rlang:defusing-advanced]{rlang::ensym()}}; either a named column (non-standard evaluation), a string.
Supports \href{https://dplyr.tidyverse.org/articles/programming.html}{tidy-eval}.}

\item{palette}{<\code{\link{color}}|\code{function}> The colour palette of the colour scale. Must be a:
\itemize{
\item vector of RGBA hex colours,
\item a palette generator function, taking a length parameter, or
\item a palette ramp created from \code{\link[scales:colour_ramp]{scales::colour_ramp()}}
}

A \code{\link[scales:colour_ramp]{scales::colour_ramp()}} interpolator is created from the input palette.}

\item{na_color}{<\code{\link{color}}> The colour value for \code{NA} input values.}

\item{limits}{<\code{c(min, max)}> The limits of the scale's input. If \code{NULL}, limits are computed
from layer data. Values outside the range of limits are clamped.}

\item{breaks}{<\code{numeric} | \code{function}> The breaks of the scale, allowing to define a piecewise scale.
The scale \code{palette} or numeric \code{range} are linearly interpolated (by length) and mapped onto \code{breaks}.
Breaks outside the \code{limits} of the scale are discarded.

If not \code{NULL}, breaks must be either:
\itemize{
\item a numeric vector
\item a breaks function, taking a numeric vector argument (e.g. \code{\link[=breaks_linear]{breaks_linear()}})
}

Defaults to \code{\link[=breaks_trans]{breaks_trans()}} where \code{trans} is the scale's transformer.}

\item{n_ticks}{<\code{number}> The number of ticks to display on the legend. Must be >= 2.
The legend size will grow and shrink depending on this value.}

\item{tick_format}{<\code{function}> A label function taking a vector of ticks returning formatted ticks.}

\item{col_label}{<\code{string} | \code{function}> A template string or a label function for customising the
column name in the legend.
\itemize{
\item if \code{col_label} is a string, \code{{.col}} may be used to represent the \code{col} name
\item if \code{col_label} is a function, the function must take a single argument: the \code{col} name
}}

\item{legend}{<\code{boolean}> Indicate whether the legend should be displayed for this scale.}

\item{range}{<\code{numeric}> The output range of the numeric scale. Must be length >= 2.
A \code{\link[stats:approxfun]{stats::approxfun()}} interpolator is created from the input range.}

\item{na_value}{<\code{number}> The output value for \code{NA} input values.}
}
\description{
Creates a continuous log1p scale, where input values are transformed with \code{\link[=symlog_trans]{symlog_trans()}}
before calculating the output. Unlike \code{\link[=scale_log]{scale_log()}}, \code{limits} may cross 0.

Symlog scales can be useful in transforming positively skewed data.
}
\seealso{
Other scales: 
\code{\link{scale_category}()},
\code{\link{scale_identity}()},
\code{\link{scale_linear}()},
\code{\link{scale_log}()},
\code{\link{scale_power}()},
\code{\link{scale_quantile}()},
\code{\link{scale_quantize}()},
\code{\link{scale_threshold}()}
}
\concept{scales}
