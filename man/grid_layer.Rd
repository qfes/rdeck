% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/deckgl-layers.R, R/doc-deckgl-layers.R
\name{grid_layer}
\alias{grid_layer}
\alias{add_grid_layer}
\alias{update_grid_layer}
\title{Grid Layer}
\usage{
add_grid_layer(
  rdeck,
  ...,
  id = uuid::UUIDgenerate(),
  name = "GridLayer",
  group_name = NULL,
  data = NULL,
  visible = TRUE,
  pickable = FALSE,
  opacity = 1,
  wrap_longitude = FALSE,
  position_format = "XYZ",
  color_format = "RGBA",
  auto_highlight = FALSE,
  highlight_color = "#00008080",
  color_domain = NULL,
  color_range = c("#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"),
  get_color_weight = 1,
  color_aggregation = "SUM",
  elevation_domain = NULL,
  elevation_range = c(0, 1000),
  get_elevation_weight = 1,
  elevation_aggregation = "SUM",
  elevation_scale = 1,
  cell_size = 1000,
  coverage = 1,
  get_position = position,
  extruded = FALSE,
  material = TRUE,
  get_color_value = NULL,
  lower_percentile = 0,
  upper_percentile = 100,
  color_scale_type = "quantize",
  get_elevation_value = NULL,
  elevation_lower_percentile = 0,
  elevation_upper_percentile = 100,
  elevation_scale_type = "linear",
  gpu_aggregation = FALSE,
  blending_mode = "normal",
  visibility_toggle = TRUE
)
}
\arguments{
\item{rdeck}{<\code{\link{rdeck}} | \code{\link{rdeck_proxy}}> An rdeck map instance.}

\item{...}{Additional parameters that will be forwarded to deck.gl javascript without
validation nor processing. All dots must be named and will be \code{camelCased} when serialised.
A warning is raised when dots are used, warning class \code{rdeck_dots_nonempty}.}

\item{id}{<\code{string}> The layer's identifier must be unique for among all layers of the same
type for a map. Defaults to \code{\link[uuid:UUIDgenerate]{uuid::UUIDgenerate()}}, but should be explicitly defined for
updatable layers in a shiny application.}

\item{name}{<\code{string}> Identifies the layer on tooltips and legends. It does
not need to be unique, but should be brief. Defaults to the deck.gl class name for the layer.}

\item{group_name}{<\code{string}> Defines the group that this layer belongs to. Currently only
effective on the layer selector, if \code{visibility_toggle = TRUE}.}

\item{data}{<\code{data.frame} | \code{\link[sf:sf]{sf}} | \code{string}> The layer's data. Data frames and
sf objects will contain all columns that are referenced by the layer's accessors. Strings
will be interpreted as a URL and data will be retrieved dynamically in the browser.}

\item{visible}{<\code{boolean}> Determines whether the layer is visible or not; also determines
whether any legend elements for the layer will be displayed.
When \code{visble = NULL}:
\itemize{
\item on update, use current state in the browser
\item on add, layer is visible
}}

\item{pickable}{<\code{boolean}> Determines if the layer responds to pointer / touch events.}

\item{opacity}{<\code{number}> Determines the layer's opacity.}

\item{wrap_longitude}{<\code{boolean}> Normalises geometry longitudes.}

\item{position_format}{<\code{"XY"} | \code{"XYZ"}> Determines whether each coordinate has two (XY)
or three (XYZ) elements.}

\item{color_format}{<\code{"RGB"} | \code{"RGBA"}> Determines whether the alpha channel of the colours
will be ignored by accessors, making all colours opaque.}

\item{auto_highlight}{<\code{boolean}> When \code{TRUE}, the current object \emph{hovered} by the cursor is
highlighted by \code{highlight_color}.}

\item{highlight_color}{<\code{\link{accessor}} | \code{\link{scale}} | \code{\link{color}}> When \code{auto_highlight} and
\code{pickable} are enabled, \code{highlight_color} determines the colour of the currently
highlighted object. If a single colour value is supplied, that colour will be used to
highlight all objects in the layer. Per-object highlighting is achieved with a colour scale,
or a \href{https://dplyr.tidyverse.org/articles/programming.html}{tidy-eval} column of colours.}

\item{color_domain}{<\code{number}> The colour scale domain, default is set to the range
of aggregated weights in each bin.}

\item{color_range}{<\code{\link{color}}> The colour palette.
\code{color_domain} is divided into \code{length(color_range)} equal segments, each mapped to
one color in \code{color_range}.}

\item{get_color_weight}{<\code{\link{accessor}} | \code{\link{scale}} | \code{number}> The weight of each object used
to calculate the colour value for a bin.
Accepts a single numeric value, a numeric scale, or a
\href{https://dplyr.tidyverse.org/articles/programming.html}{tidy-eval} column of numbers.}

\item{color_aggregation}{<\code{"SUM"} | \code{"MEAN"} | \code{"MIN"} | \code{"MAX"}>  Operation used to
aggregate data values/weights to calculate a bin's colour.}

\item{elevation_domain}{<\code{number}> The elevation scale input domain. Defaults to the range
of the aggregated weights in each bin.}

\item{elevation_range}{<\code{number}> The elevation scale output range.}

\item{get_elevation_weight}{<\code{\link{accessor}} | \code{\link{scale}} | `numeric> The weight of each object used
to calculate the elevation value for a bin.
Accepts a single numeric value, a numeric scale, or a
\href{https://dplyr.tidyverse.org/articles/programming.html}{tidy-eval} column of numbers.}

\item{elevation_aggregation}{<\code{"SUM"} | \code{"MEAN"} | \code{"MIN"} | \code{"MAX"}> Operation used to
aggregate data values/weights to calculate a bin's elevation value.}

\item{elevation_scale}{<\code{number}> The elevation multiplier.}

\item{cell_size}{<\code{number}> The size of each cell in metres.}

\item{coverage}{<\code{number}> Radius multiplier, between 0 - 1. The radius of each disk is
calculated by \code{coverage * radius}.}

\item{get_position}{<\code{\link{accessor}}> The position geometry column, either a \code{sfc_POINT} or
a \code{sfc_MULTIPOINT} column with CRS \href{http://epsg.io/4326}{EPSG:4326}.
Supports \href{https://dplyr.tidyverse.org/articles/programming.html}{tidy-eval}.}

\item{extruded}{<\code{boolean}> If \code{TRUE}, extrude objects along the z-axis; if \code{FALSE}, all
objects will be flat.}

\item{material}{<\code{boolean}>}

\item{get_color_value}{<\code{\link[htmlwidgets:JS]{JS}}> After data objects are aggregated into bins,
this accessor is called on each bin to get the value that its colour is based on. If supplied,
this will override the effect of \code{get_color_weight} and \code{color_aggregation} props.
See deck.gl docs for details.}

\item{lower_percentile}{<\code{number}> Between \code{0} and \code{100}. Filter bins and re-calculate colour
by \code{lower_percentile}. Cells with \code{value < lower_percentile} will be hidden.}

\item{upper_percentile}{<\code{number}> Between \code{0} and \code{100}. Filter bins and re-calculate colour
by \code{upper_percentile}. Cells with \code{value < upper_percentile} will be hidden.}

\item{color_scale_type}{<\code{"quantize"} | \code{"linear"} | \code{"quantile"} | \code{"ordinal"}> The scaling
function used to determine the colour of a the grid cell.}

\item{get_elevation_value}{<\code{\link[htmlwidgets:JS]{JS}}> After data objects are aggregated into
bins, this accessor is called on each bin to get the value that its elevation is based on.
If supplied, this will override the effect of \code{get_elevation_weight} and
\code{elevation_aggregation} props.
See deck.gl docs for details.}

\item{elevation_lower_percentile}{<\code{number}> Between \code{0} and \code{100}. Filter bins and
re-calculate elevation by \code{elevation_lower_percentile}.
Cells with \code{value < elevation_lower_percentile} will be hidden.}

\item{elevation_upper_percentile}{<\code{number}> Between \code{0} and \code{100}. Filter bins and
re-calculate elevation by \code{elevation_upper_percentile}.
Cells with \code{value < elevation_upper_percentile} will be hidden.}

\item{elevation_scale_type}{<\code{"quantize"} | \code{"linear"} | \code{"quantile"} | \code{"ordinal"}> The scaling
function used to determine the elevation of a the grid cell.}

\item{gpu_aggregation}{<\code{boolean}> If \code{TRUE}, aggregation is performed on GPU if supported.
Requires \code{WebGL2}.}

\item{blending_mode}{<\code{"normal"} | \code{"additive"} | \code{"subtractive"}> Sets the blending mode.
Blending modes:
\itemize{
\item \code{normal}: Normal blending doesn't alter colours of overlapping objects.
\item \code{additive}: Additive blending adds colours of overlapping objects. Useful for highlighting
dot density on dark maps.
\item \code{subtractive}: Subtractive blending darkens overlapping objects. Useful for highlighting
dot density on light maps.
}}

\item{visibility_toggle}{<\code{boolean}> Whether this layer will appear in the layer selector.}
}
\description{
Grid Layer
}
\seealso{
\url{https://github.com/visgl/deck.gl/blob/8.7-release/docs/api-reference/aggregation-layers/grid-layer.md}

Other aggregation-layers: 
\code{\link{contour_layer}},
\code{\link{cpu_grid_layer}},
\code{\link{gpu_grid_layer}},
\code{\link{heatmap_layer}},
\code{\link{hexagon_layer}},
\code{\link{screen_grid_layer}}

Other layers: 
\code{\link{arc_layer}},
\code{\link{bitmap_layer}},
\code{\link{column_layer}},
\code{\link{contour_layer}},
\code{\link{cpu_grid_layer}},
\code{\link{geojson_layer}},
\code{\link{gpu_grid_layer}},
\code{\link{great_circle_layer}},
\code{\link{grid_cell_layer}},
\code{\link{h3_cluster_layer}},
\code{\link{h3_hexagon_layer}},
\code{\link{heatmap_layer}},
\code{\link{hexagon_layer}},
\code{\link{icon_layer}},
\code{\link{line_layer}},
\code{\link{mvt_layer}},
\code{\link{path_layer}},
\code{\link{point_cloud_layer}},
\code{\link{polygon_layer}},
\code{\link{s2_layer}},
\code{\link{scatterplot_layer}},
\code{\link{scenegraph_layer}},
\code{\link{screen_grid_layer}},
\code{\link{simple_mesh_layer}},
\code{\link{solid_polygon_layer}},
\code{\link{terrain_layer}},
\code{\link{text_layer}},
\code{\link{tile_3d_layer}},
\code{\link{tile_layer}},
\code{\link{trips_layer}}
}
\concept{aggregation-layers}
\concept{layers}
