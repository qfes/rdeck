% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/deckgl-layers-doc.R, R/deckgl-layers.R
\name{hexagon_layer}
\alias{hexagon_layer}
\alias{add_hexagon_layer}
\title{Hexagon Layer}
\usage{
add_hexagon_layer(
  rdeck,
  ...,
  id = NULL,
  name = "HexagonLayer",
  data = NULL,
  visible = TRUE,
  pickable = FALSE,
  opacity = 1,
  position_format = "XYZ",
  color_format = "RGBA",
  auto_highlight = FALSE,
  highlight_color = "#00008080",
  color_domain = NULL,
  color_range = c("#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"),
  get_color_value = NULL,
  get_color_weight = 1,
  color_aggregation = "SUM",
  lower_percentile = 0,
  upper_percentile = 100,
  color_scale_type = "quantize",
  elevation_domain = NULL,
  elevation_range = c(0, 1000),
  get_elevation_value = NULL,
  get_elevation_weight = 1,
  elevation_aggregation = "SUM",
  elevation_lower_percentile = 0,
  elevation_upper_percentile = 100,
  elevation_scale = 1,
  elevation_scale_type = "linear",
  radius = 1000,
  coverage = 1,
  extruded = FALSE,
  hexagon_aggregator = NULL,
  get_position = position,
  material = TRUE,
  tooltip = FALSE
)
}
\arguments{
\item{rdeck}{<\code{\link{rdeck}} | \code{\link{rdeck_proxy}}> An rdeck map instance.}

\item{...}{Additional parameters that will be forwarded to deck.gl javascript without
validation nor processing. All dots must be named and will be \code{camelCased} when serialised.
Layers will raise a warning when dots are used, warning class \code{rdeck_dots_nonempty}.}

\item{id}{<\code{string}> The layer's identifier must be unique for among all layers of the same
type for a map. Defaults to \code{\link[uuid:UUIDgenerate]{uuid::UUIDgenerate()}}, but should be explicitly defined for
updatable layers in a shiny application.}

\item{name}{<\code{string}> Identifies the layer on tooltips and legends. It does
not need to be unique, but should be brief. Defaults to the deck.gl class name for the layer.}

\item{data}{<\code{data.frame} | \code{sf} | \code{string}> The layer's data. Data frames will contain all
columns that are referenced by the layer's accessors. Strings will be interpreted as a URL and
data will be retrieved dynamically in the browser.}

\item{visible}{<\code{logical}> Determines whether the layer is visible or not; also determines
whether any legend elements for the layer will be displayed.}

\item{pickable}{<\code{logical}> Determines if the layer responds to pointer / touch events.}

\item{opacity}{<\code{number}> Determines the layer's opacity.}

\item{position_format}{<\code{"XY"} | \code{"XYZ"}> Determines whether each coordinate has two (XY)
or three (XYZ) elements.}

\item{color_format}{<\code{"RGB"} | \code{"RGBA"}> Determines whether the alpha channel of the colours
will be ignored by accessors, making all colours opaque.}

\item{auto_highlight}{<\code{logical}> When \code{TRUE}, the current object \emph{hovered} by the cursor is
highlighted by \code{highlight_color}.}

\item{highlight_color}{<\code{\link{accessor}} | \code{\link{scale}} | \code{\link{color}}> When \code{auto_highlight} and
\code{pickable} are enabled, \code{highlight_color} determines the colour of the currently
highlighted object. If a single colour value is supplied, that colour will be used to
highlight all objects in the layer. Per-object highlighting is achieved with a colour scale,
or a \href{https://dplyr.tidyverse.org/articles/programming.html}{tidy-eval} column of colours.}

\item{color_domain}{<\code{number}> The colour scale domain, default is set to the range
of aggregated weights in each bin.}

\item{color_range}{<\code{\link{color}}> The colour palette.
\code{color_domain} is divided into \code{length(color_range)} equal segments, each mapped to
one color in \code{color_range}.}

\item{get_color_value}{<\code{\link[htmlwidgets:JS]{JS}}> After data objects are aggregated into bins,
this accessor is called on each bin to get the value that its colour is based on. If supplied,
this will override the effect of \code{get_color_weight} and \code{color_aggregation} props.
See deck.gl docs for details.}

\item{get_color_weight}{<\code{\link{accessor}} | \code{\link{scale}} | \code{number}> The weight of each object used
to calculate the colour value for a bin.
Accepts a single numeric value, a numeric scale, or a
\href{https://dplyr.tidyverse.org/articles/programming.html}{tidy-eval} column of numbers.}

\item{color_aggregation}{<\code{"SUM"} | \code{"MEAN"} | \code{"MIN"} | \code{"MAX"}>  Operation used to
aggregate data values/weights to calculate a bin's colour.}

\item{lower_percentile}{<\code{number}> Between \code{0} and \code{100}. Filter bins and re-calculate colour
by \code{lower_percentile}. Cells with \code{value < lower_percentile} will be hidden.}

\item{upper_percentile}{<\code{number}> Between \code{0} and \code{100}. Filter bins and re-calculate colour
by \code{upper_percentile}. Cells with \code{value < upper_percentile} will be hidden.}

\item{color_scale_type}{<\code{"quantize"} | \code{"linear"} | \code{"quantile"} | \code{"ordinal"}> The scaling
function used to determine the colour of a the grid cell.}

\item{elevation_domain}{<\code{number}> The elevation scale input domain. Defaults to the range
of the aggregated weights in each bin.}

\item{elevation_range}{<\code{number}> The elevation scale output range.}

\item{get_elevation_value}{<\code{\link[htmlwidgets:JS]{JS}}> After data objects are aggregated into
bins, this accessor is called on each bin to get the value that its elevation is based on.
If supplied, this will override the effect of \code{get_elevation_weight} and
\code{elevation_aggregation} props.
See deck.gl docs for details.}

\item{get_elevation_weight}{<\code{\link{accessor}} | \code{\link{scale}} | `numeric> The weight of each object used
to calculate the elevation value for a bin.
Accepts a single numeric value, a numeric scale, or a
\href{https://dplyr.tidyverse.org/articles/programming.html}{tidy-eval} column of numbers.}

\item{elevation_aggregation}{<\code{"SUM"} | \code{"MEAN"} | \code{"MIN"} | \code{"MAX"}> Operation used to
aggregate data values/weights to calculate a bin's elevation value.}

\item{elevation_lower_percentile}{<\code{number}> Between \code{0} and \code{100}. Filter bins and
re-calculate elevation by \code{elevation_lower_percentile}.
Cells with \code{value < elevation_lower_percentile} will be hidden.}

\item{elevation_upper_percentile}{<\code{number}> Between \code{0} and \code{100}. Filter bins and
re-calculate elevation by \code{elevation_upper_percentile}.
Cells with \code{value < elevation_upper_percentile} will be hidden.}

\item{elevation_scale}{<\code{number}> The elevation multiplier.}

\item{elevation_scale_type}{<\code{"quantize"} | \code{"linear"} | \code{"quantile"} | \code{"ordinal"}> The scaling
function used to determine the elevation of a the grid cell.}

\item{radius}{<\code{number}> The radius of the hexagon bin in metres.}

\item{coverage}{<\code{number}> Radius multiplier, between 0 - 1. The radius of each disk is
calculated by \code{coverage * radius}.}

\item{extruded}{<\code{logical}> If \code{TRUE}, extrude objects along the z-axis; if \code{FALSE}, all
objects will be flat.}

\item{hexagon_aggregator}{<\code{\link[htmlwidgets:JS]{JS}}> Hexagon aggregator function. Defaults
to \code{d3-hexbin}.
See deck.gl \href{https://deck.gl/docs/api-reference/aggregation-layers/hexagon-layer#hexagonaggregator}{hexagonAggregator}.}

\item{get_position}{<\code{\link{accessor}}> The position geometry column, an
\code{sfc_POINT} column with CRS \href{http://epsg.io/4326}{EPSG:4326}. Supports
\href{https://dplyr.tidyverse.org/articles/programming.html}{tidy-eval}.}

\item{material}{<\code{logical}>}

\item{tooltip}{<\code{\link{tooltip}}> Defines the columns (and their order) that will be displayed in
the layer tooltip, if \code{pickable == TRUE}. Supports <\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}>
if a \code{data} is a \code{data.frame}. \code{sfc} columns are always removed.}
}
\description{
Hexagon Layer
}
\seealso{
\url{https://github.com/visgl/deck.gl/blob/v8.3.11/docs/api-reference/aggregation-layers/hexagon-layer.md}

Other aggregation-layers: 
\code{\link{contour_layer}},
\code{\link{cpu_grid_layer}},
\code{\link{gpu_grid_layer}},
\code{\link{grid_layer}},
\code{\link{heatmap_layer}},
\code{\link{screen_grid_layer}}

Other layers: 
\code{\link{arc_layer}},
\code{\link{bitmap_layer}},
\code{\link{column_layer}},
\code{\link{contour_layer}},
\code{\link{cpu_grid_layer}},
\code{\link{geojson_layer}},
\code{\link{gpu_grid_layer}},
\code{\link{great_circle_layer}},
\code{\link{grid_cell_layer}},
\code{\link{grid_layer}},
\code{\link{h3_cluster_layer}},
\code{\link{h3_hexagon_layer}},
\code{\link{heatmap_layer}},
\code{\link{icon_layer}},
\code{\link{line_layer}},
\code{\link{mvt_layer}},
\code{\link{path_layer}},
\code{\link{point_cloud_layer}},
\code{\link{polygon_layer}},
\code{\link{s2_layer}},
\code{\link{scatterplot_layer}},
\code{\link{scenegraph_layer}},
\code{\link{screen_grid_layer}},
\code{\link{simple_mesh_layer}},
\code{\link{solid_polygon_layer}},
\code{\link{terrain_layer}},
\code{\link{text_layer}},
\code{\link{tile_3d_layer}},
\code{\link{tile_layer}},
\code{\link{trips_layer}}
}
\concept{aggregation-layers}
\concept{layers}
