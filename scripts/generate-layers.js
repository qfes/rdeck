/**
 * Generates the deck.gl layers interface for R
 * All layer functions are written to ./R/deckgl-layers.R
 */

const fs = require("fs/promises");
const path = require("path");
const ejs = require("ejs");
const deck = require("deck.gl");
const { snakeCase } = require("snake-case");
const { getProps } = require("./props");
const { styleFile } = require("./styler");

function rgba2hex(rgba) {
  const hex = (x) => ("0" + (x & 0xff).toString(16)).slice(-2);
  return "#" + rgba.map(hex).join("");
}

function quoteName(key) {
  return /^\.*[^.a-z]/i.test(key) || /[^.\w]/i.test(key) ? JSON.stringify(key) : key;
}

/**
 * @typedef {Object} PropType
 * @property {string} name
 * @property {string} type
 * @property {any} value
 * @param {PropType} prop
 */
function defaultValue({ name, type, value }) {
  if (name.endsWith("Color") && Array.isArray(value)) {
    return format(rgba2hex(value));
  }

  if (name === "colorRange" && Array.isArray(value)) {
    return format(value.map(rgba2hex));
  }

  if (type === "accessor" && typeof value === "function") {
    const [match] = /(?<=(return|=>)\s*)[^;]+/.exec(value.toString());
    return snakeCase(match.split(".").pop());
  }

  return format(value);

  function format(value) {
    if (value == null) {
      return null;
    }

    if (Array.isArray(value)) {
      return value.length === 0 ? null : `c(${value.map(format).join(", ")})`;
    }

    switch (typeof value) {
      case "boolean":
        return String(value).toUpperCase();
      case "number":
        return value;
      case "string":
        return JSON.stringify(value);
      case "object": {
        const entries = Object.entries(value);
        /* escape name */
        const sep = entries.length > 1 ? ",\n" : ", ";
        const items = entries
          .map(([k, v]) => quoteName(k) + " = " + (format(v) ?? "NULL"))
          .join(sep);
        return `list(${items})`;
      }
      default:
        return null;
    }
  }
}

function templateData(Layer) {
  return {
    name: snakeCase(Layer.layerName)
      // GeoJsonLayer -> geojson_layer
      .replace("geo_json", "geojson")
      // Tile3DLayer -> tile3d_layer
      .replace("3_d", "_3d"),
    type: Layer.layerName,
    props: getProps(Layer).map((propType) => ({
      ...propType,
      name: snakeCase(propType.name),
      value: defaultValue(propType),
    })),
  };
}

const layers = Object.values(deck)
  .filter((x) => x.prototype instanceof deck.Layer && x !== deck.CompositeLayer)
  .map(templateData);

const template = path.join(__dirname, "layer.ejs");
const output = path.join(__dirname, "../R/deckgl-layers.R");
// @ts-ignore
const deckVersion = deck.Deck.VERSION;
const generatedBy = `
  # Generated by rdeck: do not edit by hand
  # deck.gl version: ${deckVersion}
`.trim();

Promise.all(layers.map((layer) => ejs.renderFile(template, layer, { rmWhitespace: true })))
  .then((layers) => {
    const content = [generatedBy, ...layers].join("\n\n");
    return fs.writeFile(output, content);
  })
  .then(() => styleFile(output));
