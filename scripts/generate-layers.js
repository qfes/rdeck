/**
 * Generates the deck.gl layers interface for R
 * All layer functions are written to ./R/deckgl-layers.R
 */

const fs = require("fs/promises");
const path = require("path");
const ejs = require("ejs");
const deck = require("deck.gl");
const { snakeCase } = require("snake-case");
const { getProps } = require("./props");
const { styleFile } = require("./styler");

function rgba2hex(rgba) {
  const hex = (x) => ("0" + (x & 0xff).toString(16)).slice(-2);
  return "#" + rgba.map(hex).join("");
}

function quoteName(key) {
  return /^\.*[^.a-z]/i.test(key) || /[^.\w]/i.test(key) ? JSON.stringify(key) : key;
}

/**
 * @typedef {Object} PropType
 * @property {string} name
 * @property {string} type
 * @property {any} value
 * @param {PropType} prop
 */
function defaultValue({ name, type, value, valueType }) {
  if (name === "id") return "uuid::UUIDgenerate()";

  if (name === "colorRange" && Array.isArray(value)) {
    return format(value.map(rgba2hex));
  }

  if (valueType === "color" && Array.isArray(value)) {
    return format(rgba2hex(value));
  }

  if (type === "accessor" && typeof value === "function") {
    const [match] = /(?<=(return|=>)\s*)[^;]+/.exec(value.toString());
    return snakeCase(match.split(".").pop());
  }

  return format(value);

  function format(value) {
    if (value == null) {
      return null;
    }

    if (Array.isArray(value)) {
      return value.length === 0 ? null : `c(${value.map(format).join(", ")})`;
    }

    switch (typeof value) {
      case "boolean":
        return String(value).toUpperCase();
      case "number":
        return value;
      case "string":
        return JSON.stringify(value);
      case "object": {
        const entries = Object.entries(value);
        /* escape name */
        const sep = entries.length > 1 ? ",\n" : ", ";
        const items = entries
          .map(([k, v]) => quoteName(k) + " = " + (format(v) ?? "NULL"))
          .join(sep);
        return `list(${items})`;
      }
      default:
        return null;
    }
  }
}

function diffuseAccessors({ props }) {
  return props
    .filter((p) => p.type === "accessor" || p.name === "tooltip")
    .map((p) => `${p.name} <- rlang::enquo(${p.name})`)
    .join("\n");
}

function transformProps({ props }) {
  return props
    .map((p) => {
      if (p.type === "accessor") return `${p.name} = accessor(${p.name}, data)`;
      if (p.name === "tooltip") return `${p.name} = tooltip(${p.name}, data)`;

      // default
      return `${p.name} = ${p.name}`;
    })
    .join(",\n");
}

function validateProps({ name, props }) {
  return props.map((p) => `validate_${p.name}(${name})`).join("\n");
}

function templateData(Layer) {
  return {
    type: Layer,
    typeName: Layer.layerName,
    name: snakeCase(Layer.layerName)
      // GeoJsonLayer -> geojson_layer
      .replace("geo_json", "geojson")
      // Tile3DLayer -> tile3d_layer
      .replace("3_d", "_3d"),
    dataType: [deck.GeoJsonLayer, deck.MVTLayer].includes(Layer) ? "geojson" : null,
    props: getProps(Layer).map((propType) => ({
      ...propType,
      name: snakeCase(propType.name),
      value: defaultValue(propType),
    })),
  };
}

const layers = Object.values(deck)
  .filter((x) => x.prototype instanceof deck.Layer && x !== deck.CompositeLayer)
  .map(templateData);

const template = path.join(__dirname, "layer.ejs");
const output = path.join(__dirname, "../R/deckgl-layers.R");
// @ts-ignore
const deckVersion = deck.Deck.VERSION;
const generatedBy = `
  # Generated by rdeck: do not edit by hand
  # deck.gl version: ${deckVersion}
`.trim();

Promise.all(
  layers.map((layer) =>
    ejs.renderFile(
      template,
      { layer, utils: { diffuseAccessors, transformProps, validateProps } },
      { rmWhitespace: true }
    )
  )
)
  .then((layers) => {
    const content = [generatedBy, ...layers].join("\n\n");
    return fs.writeFile(output, content);
  })
  .then(() => styleFile(output));
